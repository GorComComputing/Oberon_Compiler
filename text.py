#Драйвер исходного текста

import sys #модуль для работы с аргументами командной строки
import loc
import error

chEOT = "\0"
chEOL = "\n"
chSPACE = " "
chTAB = "\t"

_src = ""   #хранит прочитанный файл (_ доступна только из этого файла)
_i = 0      #хранит номер символа    (_ доступна только из этого файла)
ch = ""     #хранит сам символ

#функция открытия и чтения файла с исходником
def Reset():
    global _src
    if len(sys.argv) < 2:  #sys.argv передает аргументы коммандной строки
        #если аргументов меньше 2-х, то сообщение об ошибке
        error.Error("Запуск: python GCCompiller.py <файл программы>")
    else:
        try:     #попытка открытия файла с исходником file.gc для GCCompiller
            _f = open(sys.argv[1])
        except:  #обработка исключения
            error.Error("Ошибка открытия файла")
        try:     #читаем весь файл с исходником в строку _src
            _src = _f.read()
        except:  #обработка исключения
            error.Error("Ошибка чтения файла")

        _f.close()  #файл больше не нужен, закрываем его
        #print(_src) #отладочный вывод файла в консоль

#функция чтения следующего символа (помещает в переменную ch)
def nextCh():
    global _src, _i, ch
    if _i < len(_src):  #проверяем не дошли ли до конца файла
        ch = _src[_i]
        # отладочная печать
        print(ch, end="") #end="" чтобы не переводил строку
        loc.pos += 1  #увеличиваем позицию символа в строке
        _i += 1       #увеличиваем позицию символа в файле
        if ch in {'\n', '\r'}: #проверяем на конец строки
            ch = chEOL  #пишем chEOL
            loc.pos = 0 #обнуляем позицию в строке
    else:
        ch = chEOT   #если конец файла пишем последний символ chEOT

